import socket
import threading
import json
import time
import uuid
import struct
import fcntl  # Solo disponible en Linux (perfecto para tus containers)


class P2PDiscovery:
    def __init__(self, interface_name="eth0", port=5000):
        self.port = port
        self.interface = interface_name
        self.group = "224.0.0.1"
        self.agent_id = str(uuid.uuid4())[:8]

        # Obtenemos la IP de la interfaz específica
        self.ip = self._get_ip_address(self.interface)
        self.mac = self._get_mac_native()

        self.peers = {}
        self.lock = threading.Lock()

    def _get_ip_address(self, ifname):
        """Obtiene la IP de una interfaz específica en Linux."""
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # Usa fcntl para consultar el stack de red de Linux
            return socket.inet_ntoa(
                fcntl.ioctl(
                    s.fileno(),
                    0x8915,  # SIOCGIFADDR
                    struct.pack("256s", ifname[:15].encode("utf-8")),
                )[20:24]
            )
        except Exception as e:
            print(f"Error: No se pudo obtener IP de {ifname}: {e}")
            return "127.0.0.1"

    def _get_mac_native(self):
        mac_num = hex(uuid.getnode()).replace("0x", "").zfill(12)
        return ":".join(mac_num[i : i + 2] for i in range(0, 11, 2))

    def broadcast_presence(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)

        # 1. Forzar que el tráfico Multicast SALGA por la IP de la interfaz elegida
        host_ip_bin = socket.inet_aton(self.ip)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF, host_ip_bin)

        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_LOOP, 1)

        data = json.dumps(
            {"agent_id": self.agent_id, "mac": self.mac, "ip": self.ip}
        ).encode("utf-8")

        while True:
            try:
                sock.sendto(data, (self.group, self.port))
            except Exception as e:
                print(f"Error enviando: {e}")
            time.sleep(5)

    def listen_for_peers(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)

        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if hasattr(socket, "SO_REUSEPORT"):
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)

        # 2. Vincular el socket a la IP de la interfaz específica (opcional pero recomendado)
        # o dejar '' para escuchar en todas pero filtrar por el grupo en la interfaz
        sock.bind(("", self.port))

        # 3. Decirle al kernel que se una al grupo Multicast SOLO en esta interfaz
        # Estructura: ip_del_grupo + ip_de_la_interfaz_local
        mreq = socket.inet_aton(self.group) + socket.inet_aton(self.ip)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

        while True:
            data, addr = sock.recvfrom(1024)
            peer_info = json.loads(data.decode("utf-8"))
            if peer_info["agent_id"] != self.agent_id:
                with self.lock:
                    peer_info["last_seen"] = time.time()
                    self.peers[peer_info["agent_id"]] = peer_info

    def start(self):
        threading.Thread(target=self.broadcast_presence, daemon=True).start()
        threading.Thread(target=self.listen_for_peers, daemon=True).start()

        print(
            f"Agente {self.agent_id} operando en interfaz {self.interface} ({self.ip})"
        )
        try:
            while True:
                time.sleep(5)
                with self.lock:
                    print(f"Peers: {list(self.peers.keys())}")
        except KeyboardInterrupt:
            pass


if __name__ == "__main__":
    # Cambia 'eth0' por el nombre real de tu interfaz (ej. 'ens33' o 'eth1')
    discovery.start()
